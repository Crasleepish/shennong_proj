---

## ✅ 项目结构概览

本项目旨在对股票因子（如 MKT、SMB、HML、QMJ）的未来走势进行分类预测，并将预测结果用于构建 Black–Litterman 投资观点，最终进行组合优化。

---

## 🧱 模块一览

| 模块名称                             | 主要功能              | 输入              | 输出                 |
| -------------------------------- | ----------------- | --------------- | ------------------ |
| `app/data_fetcher/`              | 数据读取模块（因子、宏观、ETF） | 起止日期            | DataFrame          |
| `app/features/`                  | 特征构造与预处理          | 原始数据、构造 plan    | 特征 DataFrame       |
| `app/ml/dataset_builder.py`      | 构建训练数据集（X,Y）      | 起止日期、目标任务名      | X: 特征, Y: 标签       |
| `app/ml/train.py`                | 模型训练，支持单次与滚动训练    | 起止日期、模型目标、拆分点   | 训练模型、测试集、预测结果、图表   |
| `app/ml/predict_and_plot.py`     | 模型推理 + 可视化        | 预测模型路径、因子名、起止日期 | 预测 vs 实际 CSV、可视化图表 |

---

## 📦 数据读取模块：`data_fetcher`

### 功能

* 提供因子每日收益率、累计净值、ETF 因子暴露等原始数据接口。

### 输入样例：

```python
FactorDataReader.read_daily_factors(start="2019-01-01", end="2023-12-31")
```

### 输出样例（DataFrame）：

| date       | MKT   | SMB   | HML    | QMJ    |
| ---------- | ----- | ----- | ------ | ------ |
| 2019-01-02 | 0.001 | 0.002 | -0.001 | 0.0005 |

---

## 🧠 特征构造模块：`features/factor_feature_pipeline.py`

### 功能

* 基于各因子收益率，构造如 z-score、动量、均线斜率等滚动特征；
* 支持多因子组合（如SMB-HML）及自定义函数。

### 输入格式：

```python
{
  "SMB": [{"func": FactorFeatureBuilder.zscore, "suffix": "z20", "kwargs": {"window": 20}}],
  ("SMB", "HML"): [{"func": lambda x, y: x - y, "suffix": "spread"}]
}
```

### 输出格式（部分）：

| date       | SMB\_z20 | SMB\_HML\_spread |
| ---------- | -------- | ---------------- |
| 2019-01-22 | 0.25     | 0.003            |

---

## 🏗️ 数据集构建模块：`dataset_builder.py`

### 功能

* 构建三分类训练数据集（X,Y）；
* 标签基于因子累计净值10日均值未来20日涨幅的历史分位数。

### 输入参数：

* `start`, `end`: 时间区间
* `vif`: 是否执行VIF剔除

### 输出：

```python
X: 特征 DataFrame
Y: 标签 DataFrame (0: 下跌, 1: 持平, 2: 上涨)
```

### 样例：

```python
X.shape → (1000, 25)
Y.shape → (1000, 1)
Y['target'].value_counts() → 0: 300, 1: 400, 2: 300
```

---

## 🎯 训练模块：`train.py`

### 功能

* 执行 rolling training，按年份逐步训练；
* 自动保存模型、预测结果、指标CSV、可视化图。

### 关键配置：

```python
date_list = ["2017-12-31", "2018-12-31", ..., "2022-12-31"]
rolling_train(start="2010-01-01", split_dates=date_list)
```

### 输出结果：

* `ml_results/20221231_model.pkl`：模型文件
* `ml_results/20221231_Y_pred.csv`：预测值
* `ml_results/20221231_metrics.csv`：分类报告（精度、召回、F1）

---

## 🔍 推理与可视化模块：`predict_and_plot.py`

### 功能

* 载入模型，对指定时间区间内数据预测；
* 可绘制因子净值曲线，标注预测点（label=0/2）；
* 支持输出预测与实际标签对比CSV。

### 输出样例（CSV）：

| date       | pred | true | prob\_0 | prob\_1 | prob\_2 |
| ---------- | ---- | ---- | ------- | ------- | ------- |
| 2023-01-02 | 2    | 1    | 0.05    | 0.20    | 0.75    |

---

# 📌《项目结构》补丁（Patch）

## **v2.0 目录结构新增与变更**

---

## **1. 新增/调整的模块**

### ✔ gold_view_llm.py

处理：

* 期货结构抓取（barchart）
* CFTC 报告解析
* LLM 调用（主观判断）
* 输出黄金主观观点 view（五档）
* 输出基于 rolling 区间均值的 ER_gold

### ✔ gold_data_fetcher（增补）

新增：

* get_future_curve()
* get_cftc_reports()
* 数据库缓存与刷新逻辑

---

## **2. dataset_builder.py 更新**

新增 rolling 标签功能：

* rolling 分位数打标
* 多任务统一的 label_to_ret 计算
* 仅 MKT/10YBond 需要 ML label
* GOLD/SMB/HML/QMJ 用 rolling 方法

---

## **3. train_pipeline.py 更新**

各任务分为：

| 任务          | 标签方式             | 预测方式                     | 是否走 BL   |
| ----------- | ---------------- | ------------------------ | -------- |
| MKT         | ML label         | ML softprob → ER_ml      | 是        |
| SMB/HML/QMJ | rolling label    | rolling 全概率 → ER_stat    | 是        |
| 10YBond     | rolling+ML label | ER_stat + ER_ml → ER_mix | 是        |
| GOLD        | rolling label    | rolling 区间均值 + LLM 档位    | 否（直接当 μ） |

---

## **4. optimize_portfolio.py（BL 逻辑）更新**

* 观点矩阵构造：基于 ER_stat / ER_ml / ER_mix / ER_gold
* GOLD 不进入 BL（跳过）
* SMB/HML/QMJ/10YBond/MKT 使用 BL（根据任务类型）
* Ω 使用“先验 + 放大预测方差”的混合方案

---

# 《项目结构更新（V3.0）》

本次更新围绕 **组合观点构造（Views）**、**模型置信度校准（omega-scaling）**、**风格拥挤控制（Style Crowding）**、**黄金拥挤控制（Gold Crowding）** 四个核心模块进行重构，在整体架构中引入了三个新概念：

1. **统一绝对收益（Absolute ER）视图体系**
2. **因子观点置信度（View Confidence） → ω 动态缩放**
3. **资产级风险缩放器（Risk Scalers）**

以下更新主要涉及时序：
**(数据层) → (因子 & 资产特征层) → (BL 视图构造层) → (风险缩放层) → (组合优化层)**

---

# 1. 目录结构更新（新增与变更）

以下目录基于你当前项目布局，仅补充新增模块和重构位置。

```
app/
│
├── data_fetcher/
│    ├── macro_data_reader.py
│    ├── factor_data_reader.py
│    ├── cftc_gold_reader.py           # [NEW] 获取黄金CFTC数据
│    └── index_data_reader.py
│
├── models/
│    ├── factor_models/
│    │     ├── xgboost_mkt.py          # MKT ML模型（输出ER_ml与loss）
│    │     ├── xgboost_10ybond.py      # 10Y ML模型（可选）
│    │     └── factor_return_stat.py   # payoff + stative ER计算
│    │
│    └── scaler_models/
│          ├── confidence_scaler.py    # [NEW] 根据loss生成c_t（置信度）
│          ├── crowding_equity_scaler.py # [NEW] SMB/HML/QMJ风格拥挤缩放器
│          └── crowding_gold_scaler.py   # [NEW] 黄金risk_scaler（基于CFTC）
│
├── factor_pipeline/
│    ├── beta_estimator.py
│    ├── kalman_filter.py
│    └── prepare_factor_views.py       # [REWORK] 构造因子绝对ER视图与omega
│
├── view_pipeline/
│    ├── build_bl_views.py             # [REWORK] BL视图构建（统一绝对ER视图）
│    ├── assemble_view_matrix.py
│    └── omega_scaler.py               # [NEW] 动态omega缩放
│
├── risk_controls/
│    ├── style_risk_router.py          # [NEW] 将风格拥挤映射到资产级风险预算
│    └── gold_risk_router.py           # [NEW] 将黄金risk_scaler注入资产ER
│
├── optimizer/
│    ├── mean_variance_opt.py
│    ├── cvar_opt.py
│    └── apply_risk_scalers.py         # [REWORK] 整合所有asset-level risk scaler
│
└── inference/
     ├── inference_engine.py
     └── run_daily_rebalance.py
```

---

# 2. 模块更新内容描述（按执行顺序）

---

# （A）数据层更新

## A1. CFTC 黄金数据读取模块

文件：`cftc_gold_reader.py`（新增）

功能：

* 读取 non-commercial net long（投机性资金）

* 读取 open interest（未平仓量）

* 计算黄金拥挤度指标：
  [
  c_t = \frac{\text{noncomm_net}}{\text{open_interest}}
  ]

* 输出 DataFrame：

  ```
  date, crowding_gold
  ```

说明：若当前只有两年数据，系统使用**行业经验分位数**（q80=0.30, q95=0.36）作为默认阈值。

---

# （B）因子观点构造层（Factor View Pipeline）

文件：`prepare_factor_views.py`（重构）

## B1. 输出内容

统一输出每个因子的：

```
ER_factor[f]       # 绝对期望收益（绝对观点）
omega_factor[f]    # 动态观点方差
```

## B2. MKT / 10YBond 观点

来源：

* XGBoost ML 预测（softprob → ER_ml）
* 模型验证 loss → 信心 c_t（由 confidence_scaler.py 生成）
* ω 根据 c_t 动态缩放：

[
\omega_f = \frac{\sigma^2_{\text{prior}, f}}{c_t}
]

## B3. SMB / HML / QMJ 观点

来源：

* 长期 payoff/stat 推断（不使用ML）
* ω 固定为 prior：
  [
  \omega_f = \sigma^2_{\text{prior}, f}
  ]

不再对因子做拥挤风险扩散（全部下沉到资产级别）。

---

# （C）BL 视图层（View Pipeline）

文件：`build_bl_views.py`（重构）

## C1. 输入（汇总）

* mu_prior, Sigma_prior
* ER_factor[f], omega_factor[f]
* ER_gold
* 资产 β 矩阵（GOLD β 只有黄金ETF为1）

## C2. 输出：

BL 三元组：

* P
* q（绝对观点）
* omega_diag

并执行完整 BL 更新：

[
\mu_{post} = BL(\mu_{prior}, \Sigma_{prior}, P, q, \omega)
]

## C3. GOLD 的处理方式

* GOLD 通过因子通道进入 BL
* GOLD 只影响黄金 ETF，不影响其他资产
* GOLD 的 ω 不变，由 prior 决定

---

# （D）风险缩放层（Risk Control Pipeline）

这是 V3.0 的核心新增部分。

---

## D1. 因子风格拥挤（SMB/HML/QMJ）风险缩放器

文件：`crowding_equity_scaler.py`（新增）

逻辑：

1. 使用 `FactorDataReader.read_daily_factors(start=None, end=trade_date)` 获取全历史因子日收益率，并在内部构造滚动区间收益：
   - 对每个因子 f ∈ {SMB, HML, QMJ}，定义固定长度 L（如 L=252 交易日）：
     
     R_f(t; L) = ∏_{τ=t-L+1}^{t} (1 + r_f(τ)) - 1

2. 在最近 `lookback_days_long = 3000` 个交易日内，对所有可用的 R_f(t; L) 计算其均值 μ_{R,f} 与标准差 σ_{R,f}，得到当前调仓日对应的 z-score：

   z_f = (R_f* - μ_{R,f}) / σ_{R,f}

   若有效样本数少于 `lookback_days_min = 750`，则对该因子不启用拥挤度调整（返回 s_f = 1.0，并记录 warning）。

3. 使用固定阈值与缩放函数计算因子级缩放系数 s_f（写死，不调参）：

   - 阈值 z0 = 2.0
   - 最小缩放 s_min = 0.5

   记 abs_z = |z_f|，则：

   s_f =
   { 1,                               abs_z ≤ z0
     max(1 / (1 + (abs_z - z0)), s_min),  abs_z > z0 }

4. 缩放结果只作用于因子观点层，对应因子的长期 payoff/stat 期望收益 ER_f^base 被收缩为：

   ER_f^view = s_f · ER_f^base

   资产层不直接使用 s_f，也不改变 β_i,f 或增加额外约束；因子层 ER 的收缩会通过现有的 β 映射自然传递到各资产的 μ_i 中。

5. `crowding_equity_scaler.py` 对外输出形如：

   {
     "SMB": s_smb,
     "HML": s_hml,
     "QMJ": s_qmj
   }

   由因子视图构造模块（例如 `prepare_factor_views.py`）在构造 ER_factor_view 时应用上述缩放：
   
   ER_factor_view[f] = s_f * ER_factor_base[f]

---

## D2. 黄金拥挤度 risk_scaler

文件：`crowding_gold_scaler.py`（新增）

基于 CFTC：

[
c_t = \frac{\text{non-commercial net long}}{\text{open interest}}
]

固定经验分位数：

* q80 = 0.30
* q95 = 0.36

风险缩放器：

[
risk_scaler_{gold} =
\begin{cases}
1, & c_t \le q_{80}\
1 + \lambda \cdot \frac{c_t - q_{80}}{q_{95}-q_{80}}, & q_{80} < c_t \le q_{95}\
1 + \lambda, & c_t > q_{95}
\end{cases}
]

（λ=1 默认）

结果在资产层仅作用于黄金 ETF 的 ER：

[
ER^{final}*{gold} = \frac{ER^{BL}*{gold}}{risk_scaler_{gold}}
]

---

# （E）组合优化层（Optimizer Pipeline）

文件：

* `mean_variance_opt.py`
* `cvar_opt.py`
* `apply_risk_scalers.py`（重构）

## E1. 输入

* μ_post（BL 后验）
* Σ（协方差）
* 风格风险缩放器（style scalers）
* GOLD 风险缩放器（gold scaler）

## E2. 风险缩放注入（资产级）

对每个资产 i：

[
\mu_i^{final} = \mu_i^{post} \times risk_scale_i^{style}
]

黄金额外加一项：

[
\mu_{gold}^{final} = \frac{\mu_{gold}^{post}}{risk_scaler_{gold}}
]

其余优化逻辑（权重约束 / 风险控制）不变。

---

# 3. 运行流程（更新版）

```
1) 数据准备
   ├─ 获取价格、因子净值、宏观数据
   ├─ 获取 CFTC 黄金数据
   └─ 获取基金因子暴露（beta）

2) 构建因子 ER + ω
   ├─ MKT/10Y：ML + loss → ER + omega
   └─ SMB/HML/QMJ：payoff/stat → ER + omega_prior

3) 构建黄金 ER
   └─ LLM → ER_gold

4) Black–Litterman
   ├─ 构造 P, q, omega
   └─ 输出 μ_post

5) 风格风险缩放（资产级）
   ├─ style crowding scalers（按β加权）
   └─ gold crowding scaler（只对黄金资产）

6) 组合优化
   ├─ 注入 scalers（μ_final）
   └─ 输出 w_opt

7) 保存结果 / 实盘推送
```

---

# 4. 与旧版本的主要差异

* ⛔ 移除 MKT 技术观点（减少共线信息）

* ⛔ 不再对 SMB/HML/QMJ 做观点方差放大（统一绝对观点）

* ⛔ 黄金不再作为“因子”参与其他资产的 β

* ✅ 新增 “模型置信度 → ω” 动态缩放（MKT & 10YBond）

* ✅ 新增 “风格拥挤 → 资产级风险缩放器”

* ✅ 新增 “黄金CFTC拥挤度 → 黄金 risk_scaler”

* ✅ 全部采用“绝对 ER 视图”统一进入 BL

* ✅ 风险缩放全部发生在资产层，风险框架更清晰

---

# 5. 总结

V3.0 的结构重构实现了以下目标：

* **简化体系**：删掉冗余信号与过度自由度
* **提高稳健性**：动态ω + 拥挤风险→ 减少回测过拟合
* **提升解释性**：每个模块均有清晰经济意义
* **提升扩展性**：未来可以自然扩展多资产、多风格、多 regime

整个框架既适合严肃的学术/工业级组合管理流程，也为未来扩展 ML 模块、流量因子、跨资产相关性模型提供了可插拔结构。
